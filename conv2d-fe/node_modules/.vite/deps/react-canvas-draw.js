import {
  require_react
} from "./chunk-YSDLPTTY.js";
import {
  __commonJS,
  __toESM
} from "./chunk-ZS7NZCD4.js";

// node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var hasSymbol = typeof Symbol === "function" && Symbol.for;
        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
        function isValidElementType(type) {
          return typeof type === "string" || typeof type === "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
          type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
        }
        function typeOf(object) {
          if (typeof object === "object" && object !== null) {
            var $$typeof = object.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = object.type;
                switch (type) {
                  case REACT_ASYNC_MODE_TYPE:
                  case REACT_CONCURRENT_MODE_TYPE:
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                    return type;
                  default:
                    var $$typeofType = type && type.$$typeof;
                    switch ($$typeofType) {
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var AsyncMode = REACT_ASYNC_MODE_TYPE;
        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element2 = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        function isAsyncMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
            }
          }
          return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
        }
        function isConcurrentMode(object) {
          return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
        }
        function isContextConsumer(object) {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
          return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object) {
          return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object) {
          return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object) {
          return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo(object) {
          return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
          return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
          return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
          return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object) {
          return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        exports.AsyncMode = AsyncMode;
        exports.ConcurrentMode = ConcurrentMode;
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element2;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isValidElementType = isValidElementType;
        exports.typeOf = typeOf;
      })();
    }
  }
});

// node_modules/react-is/index.js
var require_react_is = __commonJS({
  "node_modules/react-is/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_is_development();
    }
  }
});

// node_modules/object-assign/index.js
var require_object_assign = __commonJS({
  "node_modules/object-assign/index.js"(exports, module) {
    "use strict";
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
      if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
      }
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test2 = {};
        for (var i = 0; i < 10; i++) {
          test2["_" + String.fromCharCode(i)] = i;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
          return test2[n];
        });
        if (order2.join("") !== "0123456789") {
          return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    module.exports = shouldUseNative() ? Object.assign : function(target, source) {
      var from;
      var to = toObject(target);
      var symbols;
      for (var s = 1; s < arguments.length; s++) {
        from = Object(arguments[s]);
        for (var key in from) {
          if (hasOwnProperty.call(from, key)) {
            to[key] = from[key];
          }
        }
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from);
          for (var i = 0; i < symbols.length; i++) {
            if (propIsEnumerable.call(from, symbols[i])) {
              to[symbols[i]] = from[symbols[i]];
            }
          }
        }
      }
      return to;
    };
  }
});

// node_modules/prop-types/lib/ReactPropTypesSecret.js
var require_ReactPropTypesSecret = __commonJS({
  "node_modules/prop-types/lib/ReactPropTypesSecret.js"(exports, module) {
    "use strict";
    var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    module.exports = ReactPropTypesSecret;
  }
});

// node_modules/prop-types/lib/has.js
var require_has = __commonJS({
  "node_modules/prop-types/lib/has.js"(exports, module) {
    module.exports = Function.call.bind(Object.prototype.hasOwnProperty);
  }
});

// node_modules/prop-types/checkPropTypes.js
var require_checkPropTypes = __commonJS({
  "node_modules/prop-types/checkPropTypes.js"(exports, module) {
    "use strict";
    var printWarning = function() {
    };
    if (true) {
      ReactPropTypesSecret = require_ReactPropTypesSecret();
      loggedTypeFailures = {};
      has = require_has();
      printWarning = function(text) {
        var message = "Warning: " + text;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x) {
        }
      };
    }
    var ReactPropTypesSecret;
    var loggedTypeFailures;
    var has;
    function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
      if (true) {
        for (var typeSpecName in typeSpecs) {
          if (has(typeSpecs, typeSpecName)) {
            var error;
            try {
              if (typeof typeSpecs[typeSpecName] !== "function") {
                var err = Error(
                  (componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
                );
                err.name = "Invariant Violation";
                throw err;
              }
              error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
            } catch (ex) {
              error = ex;
            }
            if (error && !(error instanceof Error)) {
              printWarning(
                (componentName || "React class") + ": type specification of " + location + " `" + typeSpecName + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof error + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
              );
            }
            if (error instanceof Error && !(error.message in loggedTypeFailures)) {
              loggedTypeFailures[error.message] = true;
              var stack = getStack ? getStack() : "";
              printWarning(
                "Failed " + location + " type: " + error.message + (stack != null ? stack : "")
              );
            }
          }
        }
      }
    }
    checkPropTypes.resetWarningCache = function() {
      if (true) {
        loggedTypeFailures = {};
      }
    };
    module.exports = checkPropTypes;
  }
});

// node_modules/prop-types/factoryWithTypeCheckers.js
var require_factoryWithTypeCheckers = __commonJS({
  "node_modules/prop-types/factoryWithTypeCheckers.js"(exports, module) {
    "use strict";
    var ReactIs = require_react_is();
    var assign = require_object_assign();
    var ReactPropTypesSecret = require_ReactPropTypesSecret();
    var has = require_has();
    var checkPropTypes = require_checkPropTypes();
    var printWarning = function() {
    };
    if (true) {
      printWarning = function(text) {
        var message = "Warning: " + text;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x) {
        }
      };
    }
    function emptyFunctionThatReturnsNull() {
      return null;
    }
    module.exports = function(isValidElement, throwOnDirectAccess) {
      var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
        if (typeof iteratorFn === "function") {
          return iteratorFn;
        }
      }
      var ANONYMOUS = "<<anonymous>>";
      var ReactPropTypes = {
        array: createPrimitiveTypeChecker("array"),
        bigint: createPrimitiveTypeChecker("bigint"),
        bool: createPrimitiveTypeChecker("boolean"),
        func: createPrimitiveTypeChecker("function"),
        number: createPrimitiveTypeChecker("number"),
        object: createPrimitiveTypeChecker("object"),
        string: createPrimitiveTypeChecker("string"),
        symbol: createPrimitiveTypeChecker("symbol"),
        any: createAnyTypeChecker(),
        arrayOf: createArrayOfTypeChecker,
        element: createElementTypeChecker(),
        elementType: createElementTypeTypeChecker(),
        instanceOf: createInstanceTypeChecker,
        node: createNodeChecker(),
        objectOf: createObjectOfTypeChecker,
        oneOf: createEnumTypeChecker,
        oneOfType: createUnionTypeChecker,
        shape: createShapeTypeChecker,
        exact: createStrictShapeTypeChecker
      };
      function is(x, y) {
        if (x === y) {
          return x !== 0 || 1 / x === 1 / y;
        } else {
          return x !== x && y !== y;
        }
      }
      function PropTypeError(message, data) {
        this.message = message;
        this.data = data && typeof data === "object" ? data : {};
        this.stack = "";
      }
      PropTypeError.prototype = Error.prototype;
      function createChainableTypeChecker(validate) {
        if (true) {
          var manualPropTypeCallCache = {};
          var manualPropTypeWarningCount = 0;
        }
        function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
          componentName = componentName || ANONYMOUS;
          propFullName = propFullName || propName;
          if (secret !== ReactPropTypesSecret) {
            if (throwOnDirectAccess) {
              var err = new Error(
                "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
              );
              err.name = "Invariant Violation";
              throw err;
            } else if (typeof console !== "undefined") {
              var cacheKey = componentName + ":" + propName;
              if (!manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors
              manualPropTypeWarningCount < 3) {
                printWarning(
                  "You are manually calling a React.PropTypes validation function for the `" + propFullName + "` prop on `" + componentName + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
                );
                manualPropTypeCallCache[cacheKey] = true;
                manualPropTypeWarningCount++;
              }
            }
          }
          if (props[propName] == null) {
            if (isRequired) {
              if (props[propName] === null) {
                return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`."));
              }
              return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`."));
            }
            return null;
          } else {
            return validate(props, propName, componentName, location, propFullName);
          }
        }
        var chainedCheckType = checkType.bind(null, false);
        chainedCheckType.isRequired = checkType.bind(null, true);
        return chainedCheckType;
      }
      function createPrimitiveTypeChecker(expectedType) {
        function validate(props, propName, componentName, location, propFullName, secret) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== expectedType) {
            var preciseType = getPreciseType(propValue);
            return new PropTypeError(
              "Invalid " + location + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`."),
              { expectedType }
            );
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createAnyTypeChecker() {
        return createChainableTypeChecker(emptyFunctionThatReturnsNull);
      }
      function createArrayOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf.");
          }
          var propValue = props[propName];
          if (!Array.isArray(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
          }
          for (var i = 0; i < propValue.length; i++) {
            var error = typeChecker(propValue, i, componentName, location, propFullName + "[" + i + "]", ReactPropTypesSecret);
            if (error instanceof Error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createElementTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!isValidElement(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createElementTypeTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!ReactIs.isValidElementType(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement type."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createInstanceTypeChecker(expectedClass) {
        function validate(props, propName, componentName, location, propFullName) {
          if (!(props[propName] instanceof expectedClass)) {
            var expectedClassName = expectedClass.name || ANONYMOUS;
            var actualClassName = getClassName(props[propName]);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createEnumTypeChecker(expectedValues) {
        if (!Array.isArray(expectedValues)) {
          if (true) {
            if (arguments.length > 1) {
              printWarning(
                "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
              );
            } else {
              printWarning("Invalid argument supplied to oneOf, expected an array.");
            }
          }
          return emptyFunctionThatReturnsNull;
        }
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          for (var i = 0; i < expectedValues.length; i++) {
            if (is(propValue, expectedValues[i])) {
              return null;
            }
          }
          var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
            var type = getPreciseType(value);
            if (type === "symbol") {
              return String(value);
            }
            return value;
          });
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` of value `" + String(propValue) + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
        }
        return createChainableTypeChecker(validate);
      }
      function createObjectOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf.");
          }
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
          }
          for (var key in propValue) {
            if (has(propValue, key)) {
              var error = typeChecker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
              if (error instanceof Error) {
                return error;
              }
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createUnionTypeChecker(arrayOfTypeCheckers) {
        if (!Array.isArray(arrayOfTypeCheckers)) {
          true ? printWarning("Invalid argument supplied to oneOfType, expected an instance of array.") : void 0;
          return emptyFunctionThatReturnsNull;
        }
        for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
          var checker = arrayOfTypeCheckers[i];
          if (typeof checker !== "function") {
            printWarning(
              "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + getPostfixForTypeWarning(checker) + " at index " + i + "."
            );
            return emptyFunctionThatReturnsNull;
          }
        }
        function validate(props, propName, componentName, location, propFullName) {
          var expectedTypes = [];
          for (var i2 = 0; i2 < arrayOfTypeCheckers.length; i2++) {
            var checker2 = arrayOfTypeCheckers[i2];
            var checkerResult = checker2(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
            if (checkerResult == null) {
              return null;
            }
            if (checkerResult.data && has(checkerResult.data, "expectedType")) {
              expectedTypes.push(checkerResult.data.expectedType);
            }
          }
          var expectedTypesMessage = expectedTypes.length > 0 ? ", expected one of type [" + expectedTypes.join(", ") + "]" : "";
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`" + expectedTypesMessage + "."));
        }
        return createChainableTypeChecker(validate);
      }
      function createNodeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          if (!isNode(props[propName])) {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function invalidValidatorError(componentName, location, propFullName, key, type) {
        return new PropTypeError(
          (componentName || "React class") + ": " + location + " type `" + propFullName + "." + key + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + type + "`."
        );
      }
      function createShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          for (var key in shapeTypes) {
            var checker = shapeTypes[key];
            if (typeof checker !== "function") {
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
            }
            var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createStrictShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          var allKeys = assign({}, props[propName], shapeTypes);
          for (var key in allKeys) {
            var checker = shapeTypes[key];
            if (has(shapeTypes, key) && typeof checker !== "function") {
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
            }
            if (!checker) {
              return new PropTypeError(
                "Invalid " + location + " `" + propFullName + "` key `" + key + "` supplied to `" + componentName + "`.\nBad object: " + JSON.stringify(props[propName], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(shapeTypes), null, "  ")
              );
            }
            var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function isNode(propValue) {
        switch (typeof propValue) {
          case "number":
          case "string":
          case "undefined":
            return true;
          case "boolean":
            return !propValue;
          case "object":
            if (Array.isArray(propValue)) {
              return propValue.every(isNode);
            }
            if (propValue === null || isValidElement(propValue)) {
              return true;
            }
            var iteratorFn = getIteratorFn(propValue);
            if (iteratorFn) {
              var iterator = iteratorFn.call(propValue);
              var step;
              if (iteratorFn !== propValue.entries) {
                while (!(step = iterator.next()).done) {
                  if (!isNode(step.value)) {
                    return false;
                  }
                }
              } else {
                while (!(step = iterator.next()).done) {
                  var entry = step.value;
                  if (entry) {
                    if (!isNode(entry[1])) {
                      return false;
                    }
                  }
                }
              }
            } else {
              return false;
            }
            return true;
          default:
            return false;
        }
      }
      function isSymbol(propType, propValue) {
        if (propType === "symbol") {
          return true;
        }
        if (!propValue) {
          return false;
        }
        if (propValue["@@toStringTag"] === "Symbol") {
          return true;
        }
        if (typeof Symbol === "function" && propValue instanceof Symbol) {
          return true;
        }
        return false;
      }
      function getPropType(propValue) {
        var propType = typeof propValue;
        if (Array.isArray(propValue)) {
          return "array";
        }
        if (propValue instanceof RegExp) {
          return "object";
        }
        if (isSymbol(propType, propValue)) {
          return "symbol";
        }
        return propType;
      }
      function getPreciseType(propValue) {
        if (typeof propValue === "undefined" || propValue === null) {
          return "" + propValue;
        }
        var propType = getPropType(propValue);
        if (propType === "object") {
          if (propValue instanceof Date) {
            return "date";
          } else if (propValue instanceof RegExp) {
            return "regexp";
          }
        }
        return propType;
      }
      function getPostfixForTypeWarning(value) {
        var type = getPreciseType(value);
        switch (type) {
          case "array":
          case "object":
            return "an " + type;
          case "boolean":
          case "date":
          case "regexp":
            return "a " + type;
          default:
            return type;
        }
      }
      function getClassName(propValue) {
        if (!propValue.constructor || !propValue.constructor.name) {
          return ANONYMOUS;
        }
        return propValue.constructor.name;
      }
      ReactPropTypes.checkPropTypes = checkPropTypes;
      ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
      ReactPropTypes.PropTypes = ReactPropTypes;
      return ReactPropTypes;
    };
  }
});

// node_modules/prop-types/index.js
var require_prop_types = __commonJS({
  "node_modules/prop-types/index.js"(exports, module) {
    if (true) {
      ReactIs = require_react_is();
      throwOnDirectAccess = true;
      module.exports = require_factoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
    } else {
      module.exports = null();
    }
    var ReactIs;
    var throwOnDirectAccess;
  }
});

// node_modules/lazy-brush/lib/Point.js
var require_Point = __commonJS({
  "node_modules/lazy-brush/lib/Point.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var Point = (
      /**
       *
       * @param {number} x
       * @param {number} y
       */
      function Point2(x, y) {
        _classCallCheck(this, Point2);
        this.x = x;
        this.y = y;
      }
    );
    exports.default = Point;
  }
});

// node_modules/lazy-brush/lib/LazyPoint.js
var require_LazyPoint = __commonJS({
  "node_modules/lazy-brush/lib/LazyPoint.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _createClass2 = /* @__PURE__ */ function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    var _Point2 = require_Point();
    var _Point3 = _interopRequireDefault(_Point2);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn(self2, call) {
      if (!self2) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return call && (typeof call === "object" || typeof call === "function") ? call : self2;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
      if (superClass)
        Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var LazyPoint = function(_Point) {
      _inherits(LazyPoint2, _Point);
      function LazyPoint2() {
        _classCallCheck(this, LazyPoint2);
        return _possibleConstructorReturn(this, (LazyPoint2.__proto__ || Object.getPrototypeOf(LazyPoint2)).apply(this, arguments));
      }
      _createClass2(LazyPoint2, [{
        key: "update",
        /**
         * Update the x and y values
         *
         * @param {Point} point
         */
        value: function update(point) {
          this.x = point.x;
          this.y = point.y;
        }
        /**
         * Move the point to another position using an angle and distance
         *
         * @param {number} angle The angle in radians
         * @param {number} distance How much the point should be moved
         */
      }, {
        key: "moveByAngle",
        value: function moveByAngle(angle, distance) {
          var angleRotated = angle + Math.PI / 2;
          this.x = this.x + Math.sin(angleRotated) * distance, this.y = this.y - Math.cos(angleRotated) * distance;
        }
        /**
         * Check if this point is the same as another point
         *
         * @param {Point} point
         * @returns {boolean}
         */
      }, {
        key: "equalsTo",
        value: function equalsTo(point) {
          return this.x === point.x && this.y === point.y;
        }
        /**
         * Get the difference for x and y axis to another point
         *
         * @param {Point} point
         * @returns {Point}
         */
      }, {
        key: "getDifferenceTo",
        value: function getDifferenceTo(point) {
          return new _Point3.default(this.x - point.x, this.y - point.y);
        }
        /**
         * Calculate distance to another point
         *
         * @param {Point} point
         * @returns {Point}
         */
      }, {
        key: "getDistanceTo",
        value: function getDistanceTo(point) {
          var diff = this.getDifferenceTo(point);
          return Math.sqrt(Math.pow(diff.x, 2) + Math.pow(diff.y, 2));
        }
        /**
         * Calculate the angle to another point
         *
         * @param {Point} point
         * @returns {Point}
         */
      }, {
        key: "getAngleTo",
        value: function getAngleTo(point) {
          var diff = this.getDifferenceTo(point);
          return Math.atan2(diff.y, diff.x);
        }
        /**
         * Return a simple object with x and y properties
         *
         * @returns {object}
         */
      }, {
        key: "toObject",
        value: function toObject() {
          return {
            x: this.x,
            y: this.y
          };
        }
      }]);
      return LazyPoint2;
    }(_Point3.default);
    exports.default = LazyPoint;
  }
});

// node_modules/lazy-brush/lib/LazyBrush.js
var require_LazyBrush = __commonJS({
  "node_modules/lazy-brush/lib/LazyBrush.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _createClass2 = /* @__PURE__ */ function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    var _LazyPoint = require_LazyPoint();
    var _LazyPoint2 = _interopRequireDefault(_LazyPoint);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var RADIUS_DEFAULT = 30;
    var LazyBrush2 = function() {
      function LazyBrush3() {
        var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref$radius = _ref.radius, radius = _ref$radius === void 0 ? RADIUS_DEFAULT : _ref$radius, _ref$enabled = _ref.enabled, enabled = _ref$enabled === void 0 ? true : _ref$enabled, _ref$initialPoint = _ref.initialPoint, initialPoint = _ref$initialPoint === void 0 ? { x: 0, y: 0 } : _ref$initialPoint;
        _classCallCheck(this, LazyBrush3);
        this.radius = radius;
        this._isEnabled = enabled;
        this.pointer = new _LazyPoint2.default(initialPoint.x, initialPoint.y);
        this.brush = new _LazyPoint2.default(initialPoint.x, initialPoint.y);
        this.angle = 0;
        this.distance = 0;
        this._hasMoved = false;
      }
      _createClass2(LazyBrush3, [{
        key: "enable",
        value: function enable() {
          this._isEnabled = true;
        }
        /**
         * Disable lazy brush calculations.
         *
         */
      }, {
        key: "disable",
        value: function disable() {
          this._isEnabled = false;
        }
        /**
         * @returns {boolean}
         */
      }, {
        key: "isEnabled",
        value: function isEnabled() {
          return this._isEnabled;
        }
        /**
         * Update the radius
         *
         * @param {number} radius
         */
      }, {
        key: "setRadius",
        value: function setRadius(radius) {
          this.radius = radius;
        }
        /**
         * Return the current radius
         *
         * @returns {number}
         */
      }, {
        key: "getRadius",
        value: function getRadius() {
          return this.radius;
        }
        /**
         * Return the brush coordinates as a simple object
         *
         * @returns {object}
         */
      }, {
        key: "getBrushCoordinates",
        value: function getBrushCoordinates() {
          return this.brush.toObject();
        }
        /**
         * Return the pointer coordinates as a simple object
         *
         * @returns {object}
         */
      }, {
        key: "getPointerCoordinates",
        value: function getPointerCoordinates() {
          return this.pointer.toObject();
        }
        /**
         * Return the brush as a LazyPoint
         *
         * @returns {LazyPoint}
         */
      }, {
        key: "getBrush",
        value: function getBrush() {
          return this.brush;
        }
        /**
         * Return the pointer as a LazyPoint
         *
         * @returns {LazyPoint}
         */
      }, {
        key: "getPointer",
        value: function getPointer() {
          return this.pointer;
        }
        /**
         * Return the angle between pointer and brush
         *
         * @returns {number} Angle in radians
         */
      }, {
        key: "getAngle",
        value: function getAngle() {
          return this.angle;
        }
        /**
         * Return the distance between pointer and brush
         *
         * @returns {number} Distance in pixels
         */
      }, {
        key: "getDistance",
        value: function getDistance() {
          return this.distance;
        }
        /**
         * Return if the previous update has moved the brush.
         *
         * @returns {boolean} Whether the brush moved previously.
         */
      }, {
        key: "brushHasMoved",
        value: function brushHasMoved() {
          return this._hasMoved;
        }
        /**
         * Updates the pointer point and calculates the new brush point.
         *
         * @param {Point} newPointerPoint
         * @param {Object} options
         * @param {Boolean} options.both Force update pointer and brush
         * @returns {Boolean} Whether any of the two points changed
         */
      }, {
        key: "update",
        value: function update(newPointerPoint) {
          var _ref2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref2$both = _ref2.both, both = _ref2$both === void 0 ? false : _ref2$both;
          this._hasMoved = false;
          if (this.pointer.equalsTo(newPointerPoint) && !both) {
            return false;
          }
          this.pointer.update(newPointerPoint);
          if (both) {
            this._hasMoved = true;
            this.brush.update(newPointerPoint);
            return true;
          }
          if (this._isEnabled) {
            this.distance = this.pointer.getDistanceTo(this.brush);
            this.angle = this.pointer.getAngleTo(this.brush);
            if (this.distance > this.radius) {
              this.brush.moveByAngle(this.angle, this.distance - this.radius);
              this._hasMoved = true;
            }
          } else {
            this.distance = 0;
            this.angle = 0;
            this.brush.update(newPointerPoint);
            this._hasMoved = true;
          }
          return true;
        }
      }]);
      return LazyBrush3;
    }();
    exports.default = LazyBrush2;
  }
});

// node_modules/lazy-brush/lib/index.js
var require_lib = __commonJS({
  "node_modules/lazy-brush/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.LazyPoint = exports.Point = exports.LazyBrush = void 0;
    var _LazyBrush = require_LazyBrush();
    var _LazyBrush2 = _interopRequireDefault(_LazyBrush);
    var _Point = require_Point();
    var _Point2 = _interopRequireDefault(_Point);
    var _LazyPoint = require_LazyPoint();
    var _LazyPoint2 = _interopRequireDefault(_LazyPoint);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    exports.LazyBrush = _LazyBrush2.default;
    exports.Point = _Point2.default;
    exports.LazyPoint = _LazyPoint2.default;
  }
});

// node_modules/catenary-curve/lib/Point.js
var require_Point2 = __commonJS({
  "node_modules/catenary-curve/lib/Point.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _createClass2 = /* @__PURE__ */ function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var Point = function() {
      function Point2(x, y) {
        _classCallCheck(this, Point2);
        this.x = x;
        this.y = y;
      }
      _createClass2(Point2, [{
        key: "update",
        value: function update(point) {
          this.x = point.x;
          this.y = point.y;
        }
        /**
         * Get the difference for x and y axis to another point
         *
         * @param {Point} point
         * @returns {Point}
         */
      }, {
        key: "getDifferenceTo",
        value: function getDifferenceTo(point) {
          return new Point2(this.x - point.x, this.y - point.y);
        }
        /**
         * Calculate distance to another point
         *
         * @param {Point} point
         * @returns {Point}
         */
      }, {
        key: "getDistanceTo",
        value: function getDistanceTo(point) {
          var diff = this.getDifferenceTo(point);
          return Math.sqrt(Math.pow(diff.x, 2) + Math.pow(diff.y, 2));
        }
      }]);
      return Point2;
    }();
    exports.default = Point;
  }
});

// node_modules/catenary-curve/lib/Catenary.js
var require_Catenary = __commonJS({
  "node_modules/catenary-curve/lib/Catenary.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _createClass2 = /* @__PURE__ */ function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    var _Point = require_Point2();
    var _Point2 = _interopRequireDefault(_Point);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var EPSILON = 1e-6;
    var Catenary2 = function() {
      function Catenary3() {
        var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref$segments = _ref.segments, segments = _ref$segments === void 0 ? 50 : _ref$segments, _ref$iterationLimit = _ref.iterationLimit, iterationLimit = _ref$iterationLimit === void 0 ? 100 : _ref$iterationLimit;
        _classCallCheck(this, Catenary3);
        this.p1 = new _Point2.default();
        this.p2 = new _Point2.default();
        this.segments = segments;
        this.iterationLimit = iterationLimit;
      }
      _createClass2(Catenary3, [{
        key: "drawToCanvas",
        value: function drawToCanvas(context, point1, point2, chainLength) {
          this.p1.update(point1);
          this.p2.update(point2);
          var isFlipped = this.p1.x > this.p2.x;
          var p1 = isFlipped ? this.p2 : this.p1;
          var p2 = isFlipped ? this.p1 : this.p2;
          var distance = p1.getDistanceTo(p2);
          var curveData = [];
          var isStraight = true;
          if (distance < chainLength) {
            var diff = p2.x - p1.x;
            if (diff > 0.01) {
              var h = p2.x - p1.x;
              var v = p2.y - p1.y;
              var a = -this.getCatenaryParameter(h, v, chainLength, this.iterationLimit);
              var x = (a * Math.log((chainLength + v) / (chainLength - v)) - h) * 0.5;
              var y = a * Math.cosh(x / a);
              var offsetX = p1.x - x;
              var offsetY = p1.y - y;
              curveData = this.getCurve(a, p1, p2, offsetX, offsetY, this.segments);
              isStraight = false;
            } else {
              var mx = (p1.x + p2.x) * 0.5;
              var my = (p1.y + p2.y + chainLength) * 0.5;
              curveData = [[p1.x, p1.y], [mx, my], [p2.x, p2.y]];
            }
          } else {
            curveData = [[p1.x, p1.y], [p2.x, p2.y]];
          }
          if (isStraight) {
            this.drawLine(curveData, context);
          } else {
            this.drawCurve(curveData, context);
          }
          return curveData;
        }
        /**
         * Determines catenary parameter.
         * 
         * @param {Number} h Horizontal distance of both points.
         * @param {Number} v Vertical distance of both points.
         * @param {Number} length The catenary length.
         * @param {Number} limit Maximum amount of iterations to find parameter.
         */
      }, {
        key: "getCatenaryParameter",
        value: function getCatenaryParameter(h, v, length, limit) {
          var m = Math.sqrt(length * length - v * v) / h;
          var x = Math.acosh(m) + 1;
          var prevx = -1;
          var count = 0;
          while (Math.abs(x - prevx) > EPSILON && count < limit) {
            prevx = x;
            x = x - (Math.sinh(x) - m * x) / (Math.cosh(x) - m);
            count++;
          }
          return h / (2 * x);
        }
        /**
         * Calculate the catenary curve.
         * Increasing the segments value will produce a catenary closer
         * to reality, but will require more calcluations.
         * 
         * @param {Number} a The catenary parameter.
         * @param {Point} p1 First point
         * @param {Point} p2 Second point
         * @param {Number} offsetX The calculated offset on the x axis.
         * @param {Number} offsetY The calculated offset on the y axis.
         * @param {Number} segments How many "parts" the chain should be made of.
         */
      }, {
        key: "getCurve",
        value: function getCurve(a, p1, p2, offsetX, offsetY, segments) {
          var data = [p1.x, a * Math.cosh((p1.x - offsetX) / a) + offsetY];
          var d = p2.x - p1.x;
          var length = segments - 1;
          for (var i = 0; i < length; i++) {
            var x = p1.x + d * (i + 0.5) / length;
            var y = a * Math.cosh((x - offsetX) / a) + offsetY;
            data.push(x, y);
          }
          data.push(p2.x, a * Math.cosh((p2.x - offsetX) / a) + offsetY);
          return data;
        }
        /**
         * Draws a straight line between two points.
         *
         * @param {Array} data Even indices are x, odd are y.
         * @param {CanvasRenderingContext2D} context The context to draw to.
         */
      }, {
        key: "drawLine",
        value: function drawLine(data, context) {
          context.moveTo(data[0][0], data[0][1]);
          context.lineTo(data[1][0], data[1][1]);
        }
        /**
         * Draws a quadratic curve between every calculated catenary segment,
         * so that the segments don't look like straight lines.
         *
         * @param {Array} data Even indices are x, odd are y.
         * @param {CanvasRenderingContext2D} context The context to draw to.
         * 
         * @returns {Array} The original segment coordinates.
         */
      }, {
        key: "drawCurve",
        value: function drawCurve(data, context) {
          var length = data.length * 0.5 - 1;
          var ox = data[2];
          var oy = data[3];
          var temp = [];
          context.moveTo(data[0], data[1]);
          for (var i = 2; i < length; i++) {
            var x = data[i * 2];
            var y = data[i * 2 + 1];
            var mx = (x + ox) * 0.5;
            var my = (y + oy) * 0.5;
            temp.push([ox, oy, mx, my]);
            context.quadraticCurveTo(ox, oy, mx, my);
            ox = x;
            oy = y;
          }
          length = data.length;
          context.quadraticCurveTo(data[length - 4], data[length - 3], data[length - 2], data[length - 1]);
          return temp;
        }
      }]);
      return Catenary3;
    }();
    exports.default = Catenary2;
  }
});

// node_modules/catenary-curve/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/catenary-curve/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Point = exports.Catenary = void 0;
    var _Catenary = require_Catenary();
    var _Catenary2 = _interopRequireDefault(_Catenary);
    var _Point = require_Point2();
    var _Point2 = _interopRequireDefault(_Point);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    exports.Catenary = _Catenary2.default;
    exports.Point = _Point2.default;
  }
});

// node_modules/react-canvas-draw/es/index.js
var import_react = __toESM(require_react());
var import_prop_types = __toESM(require_prop_types());
var import_lazy_brush = __toESM(require_lib());
var import_catenary_curve = __toESM(require_lib2());

// node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js
var MapShim = function() {
  if (typeof Map !== "undefined") {
    return Map;
  }
  function getIndex(arr, key) {
    var result = -1;
    arr.some(function(entry, index2) {
      if (entry[0] === key) {
        result = index2;
        return true;
      }
      return false;
    });
    return result;
  }
  return (
    /** @class */
    function() {
      function class_1() {
        this.__entries__ = [];
      }
      Object.defineProperty(class_1.prototype, "size", {
        /**
         * @returns {boolean}
         */
        get: function() {
          return this.__entries__.length;
        },
        enumerable: true,
        configurable: true
      });
      class_1.prototype.get = function(key) {
        var index2 = getIndex(this.__entries__, key);
        var entry = this.__entries__[index2];
        return entry && entry[1];
      };
      class_1.prototype.set = function(key, value) {
        var index2 = getIndex(this.__entries__, key);
        if (~index2) {
          this.__entries__[index2][1] = value;
        } else {
          this.__entries__.push([key, value]);
        }
      };
      class_1.prototype.delete = function(key) {
        var entries = this.__entries__;
        var index2 = getIndex(entries, key);
        if (~index2) {
          entries.splice(index2, 1);
        }
      };
      class_1.prototype.has = function(key) {
        return !!~getIndex(this.__entries__, key);
      };
      class_1.prototype.clear = function() {
        this.__entries__.splice(0);
      };
      class_1.prototype.forEach = function(callback, ctx) {
        if (ctx === void 0) {
          ctx = null;
        }
        for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
          var entry = _a[_i];
          callback.call(ctx, entry[1], entry[0]);
        }
      };
      return class_1;
    }()
  );
}();
var isBrowser = typeof window !== "undefined" && typeof document !== "undefined" && window.document === document;
var global$1 = function() {
  if (typeof global !== "undefined" && global.Math === Math) {
    return global;
  }
  if (typeof self !== "undefined" && self.Math === Math) {
    return self;
  }
  if (typeof window !== "undefined" && window.Math === Math) {
    return window;
  }
  return Function("return this")();
}();
var requestAnimationFrame$1 = function() {
  if (typeof requestAnimationFrame === "function") {
    return requestAnimationFrame.bind(global$1);
  }
  return function(callback) {
    return setTimeout(function() {
      return callback(Date.now());
    }, 1e3 / 60);
  };
}();
var trailingTimeout = 2;
function throttle(callback, delay) {
  var leadingCall = false, trailingCall = false, lastCallTime = 0;
  function resolvePending() {
    if (leadingCall) {
      leadingCall = false;
      callback();
    }
    if (trailingCall) {
      proxy();
    }
  }
  function timeoutCallback() {
    requestAnimationFrame$1(resolvePending);
  }
  function proxy() {
    var timeStamp = Date.now();
    if (leadingCall) {
      if (timeStamp - lastCallTime < trailingTimeout) {
        return;
      }
      trailingCall = true;
    } else {
      leadingCall = true;
      trailingCall = false;
      setTimeout(timeoutCallback, delay);
    }
    lastCallTime = timeStamp;
  }
  return proxy;
}
var REFRESH_DELAY = 20;
var transitionKeys = ["top", "right", "bottom", "left", "width", "height", "size", "weight"];
var mutationObserverSupported = typeof MutationObserver !== "undefined";
var ResizeObserverController = (
  /** @class */
  function() {
    function ResizeObserverController2() {
      this.connected_ = false;
      this.mutationEventsAdded_ = false;
      this.mutationsObserver_ = null;
      this.observers_ = [];
      this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
      this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
    }
    ResizeObserverController2.prototype.addObserver = function(observer) {
      if (!~this.observers_.indexOf(observer)) {
        this.observers_.push(observer);
      }
      if (!this.connected_) {
        this.connect_();
      }
    };
    ResizeObserverController2.prototype.removeObserver = function(observer) {
      var observers2 = this.observers_;
      var index2 = observers2.indexOf(observer);
      if (~index2) {
        observers2.splice(index2, 1);
      }
      if (!observers2.length && this.connected_) {
        this.disconnect_();
      }
    };
    ResizeObserverController2.prototype.refresh = function() {
      var changesDetected = this.updateObservers_();
      if (changesDetected) {
        this.refresh();
      }
    };
    ResizeObserverController2.prototype.updateObservers_ = function() {
      var activeObservers = this.observers_.filter(function(observer) {
        return observer.gatherActive(), observer.hasActive();
      });
      activeObservers.forEach(function(observer) {
        return observer.broadcastActive();
      });
      return activeObservers.length > 0;
    };
    ResizeObserverController2.prototype.connect_ = function() {
      if (!isBrowser || this.connected_) {
        return;
      }
      document.addEventListener("transitionend", this.onTransitionEnd_);
      window.addEventListener("resize", this.refresh);
      if (mutationObserverSupported) {
        this.mutationsObserver_ = new MutationObserver(this.refresh);
        this.mutationsObserver_.observe(document, {
          attributes: true,
          childList: true,
          characterData: true,
          subtree: true
        });
      } else {
        document.addEventListener("DOMSubtreeModified", this.refresh);
        this.mutationEventsAdded_ = true;
      }
      this.connected_ = true;
    };
    ResizeObserverController2.prototype.disconnect_ = function() {
      if (!isBrowser || !this.connected_) {
        return;
      }
      document.removeEventListener("transitionend", this.onTransitionEnd_);
      window.removeEventListener("resize", this.refresh);
      if (this.mutationsObserver_) {
        this.mutationsObserver_.disconnect();
      }
      if (this.mutationEventsAdded_) {
        document.removeEventListener("DOMSubtreeModified", this.refresh);
      }
      this.mutationsObserver_ = null;
      this.mutationEventsAdded_ = false;
      this.connected_ = false;
    };
    ResizeObserverController2.prototype.onTransitionEnd_ = function(_a) {
      var _b = _a.propertyName, propertyName = _b === void 0 ? "" : _b;
      var isReflowProperty = transitionKeys.some(function(key) {
        return !!~propertyName.indexOf(key);
      });
      if (isReflowProperty) {
        this.refresh();
      }
    };
    ResizeObserverController2.getInstance = function() {
      if (!this.instance_) {
        this.instance_ = new ResizeObserverController2();
      }
      return this.instance_;
    };
    ResizeObserverController2.instance_ = null;
    return ResizeObserverController2;
  }()
);
var defineConfigurable = function(target, props) {
  for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
    var key = _a[_i];
    Object.defineProperty(target, key, {
      value: props[key],
      enumerable: false,
      writable: false,
      configurable: true
    });
  }
  return target;
};
var getWindowOf = function(target) {
  var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
  return ownerGlobal || global$1;
};
var emptyRect = createRectInit(0, 0, 0, 0);
function toFloat(value) {
  return parseFloat(value) || 0;
}
function getBordersSize(styles) {
  var positions = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    positions[_i - 1] = arguments[_i];
  }
  return positions.reduce(function(size, position) {
    var value = styles["border-" + position + "-width"];
    return size + toFloat(value);
  }, 0);
}
function getPaddings(styles) {
  var positions = ["top", "right", "bottom", "left"];
  var paddings = {};
  for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
    var position = positions_1[_i];
    var value = styles["padding-" + position];
    paddings[position] = toFloat(value);
  }
  return paddings;
}
function getSVGContentRect(target) {
  var bbox = target.getBBox();
  return createRectInit(0, 0, bbox.width, bbox.height);
}
function getHTMLElementContentRect(target) {
  var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
  if (!clientWidth && !clientHeight) {
    return emptyRect;
  }
  var styles = getWindowOf(target).getComputedStyle(target);
  var paddings = getPaddings(styles);
  var horizPad = paddings.left + paddings.right;
  var vertPad = paddings.top + paddings.bottom;
  var width = toFloat(styles.width), height = toFloat(styles.height);
  if (styles.boxSizing === "border-box") {
    if (Math.round(width + horizPad) !== clientWidth) {
      width -= getBordersSize(styles, "left", "right") + horizPad;
    }
    if (Math.round(height + vertPad) !== clientHeight) {
      height -= getBordersSize(styles, "top", "bottom") + vertPad;
    }
  }
  if (!isDocumentElement(target)) {
    var vertScrollbar = Math.round(width + horizPad) - clientWidth;
    var horizScrollbar = Math.round(height + vertPad) - clientHeight;
    if (Math.abs(vertScrollbar) !== 1) {
      width -= vertScrollbar;
    }
    if (Math.abs(horizScrollbar) !== 1) {
      height -= horizScrollbar;
    }
  }
  return createRectInit(paddings.left, paddings.top, width, height);
}
var isSVGGraphicsElement = function() {
  if (typeof SVGGraphicsElement !== "undefined") {
    return function(target) {
      return target instanceof getWindowOf(target).SVGGraphicsElement;
    };
  }
  return function(target) {
    return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === "function";
  };
}();
function isDocumentElement(target) {
  return target === getWindowOf(target).document.documentElement;
}
function getContentRect(target) {
  if (!isBrowser) {
    return emptyRect;
  }
  if (isSVGGraphicsElement(target)) {
    return getSVGContentRect(target);
  }
  return getHTMLElementContentRect(target);
}
function createReadOnlyRect(_a) {
  var x = _a.x, y = _a.y, width = _a.width, height = _a.height;
  var Constr = typeof DOMRectReadOnly !== "undefined" ? DOMRectReadOnly : Object;
  var rect = Object.create(Constr.prototype);
  defineConfigurable(rect, {
    x,
    y,
    width,
    height,
    top: y,
    right: x + width,
    bottom: height + y,
    left: x
  });
  return rect;
}
function createRectInit(x, y, width, height) {
  return { x, y, width, height };
}
var ResizeObservation = (
  /** @class */
  function() {
    function ResizeObservation2(target) {
      this.broadcastWidth = 0;
      this.broadcastHeight = 0;
      this.contentRect_ = createRectInit(0, 0, 0, 0);
      this.target = target;
    }
    ResizeObservation2.prototype.isActive = function() {
      var rect = getContentRect(this.target);
      this.contentRect_ = rect;
      return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;
    };
    ResizeObservation2.prototype.broadcastRect = function() {
      var rect = this.contentRect_;
      this.broadcastWidth = rect.width;
      this.broadcastHeight = rect.height;
      return rect;
    };
    return ResizeObservation2;
  }()
);
var ResizeObserverEntry = (
  /** @class */
  /* @__PURE__ */ function() {
    function ResizeObserverEntry2(target, rectInit) {
      var contentRect = createReadOnlyRect(rectInit);
      defineConfigurable(this, { target, contentRect });
    }
    return ResizeObserverEntry2;
  }()
);
var ResizeObserverSPI = (
  /** @class */
  function() {
    function ResizeObserverSPI2(callback, controller, callbackCtx) {
      this.activeObservations_ = [];
      this.observations_ = new MapShim();
      if (typeof callback !== "function") {
        throw new TypeError("The callback provided as parameter 1 is not a function.");
      }
      this.callback_ = callback;
      this.controller_ = controller;
      this.callbackCtx_ = callbackCtx;
    }
    ResizeObserverSPI2.prototype.observe = function(target) {
      if (!arguments.length) {
        throw new TypeError("1 argument required, but only 0 present.");
      }
      if (typeof Element === "undefined" || !(Element instanceof Object)) {
        return;
      }
      if (!(target instanceof getWindowOf(target).Element)) {
        throw new TypeError('parameter 1 is not of type "Element".');
      }
      var observations = this.observations_;
      if (observations.has(target)) {
        return;
      }
      observations.set(target, new ResizeObservation(target));
      this.controller_.addObserver(this);
      this.controller_.refresh();
    };
    ResizeObserverSPI2.prototype.unobserve = function(target) {
      if (!arguments.length) {
        throw new TypeError("1 argument required, but only 0 present.");
      }
      if (typeof Element === "undefined" || !(Element instanceof Object)) {
        return;
      }
      if (!(target instanceof getWindowOf(target).Element)) {
        throw new TypeError('parameter 1 is not of type "Element".');
      }
      var observations = this.observations_;
      if (!observations.has(target)) {
        return;
      }
      observations.delete(target);
      if (!observations.size) {
        this.controller_.removeObserver(this);
      }
    };
    ResizeObserverSPI2.prototype.disconnect = function() {
      this.clearActive();
      this.observations_.clear();
      this.controller_.removeObserver(this);
    };
    ResizeObserverSPI2.prototype.gatherActive = function() {
      var _this2 = this;
      this.clearActive();
      this.observations_.forEach(function(observation) {
        if (observation.isActive()) {
          _this2.activeObservations_.push(observation);
        }
      });
    };
    ResizeObserverSPI2.prototype.broadcastActive = function() {
      if (!this.hasActive()) {
        return;
      }
      var ctx = this.callbackCtx_;
      var entries = this.activeObservations_.map(function(observation) {
        return new ResizeObserverEntry(observation.target, observation.broadcastRect());
      });
      this.callback_.call(ctx, entries, ctx);
      this.clearActive();
    };
    ResizeObserverSPI2.prototype.clearActive = function() {
      this.activeObservations_.splice(0);
    };
    ResizeObserverSPI2.prototype.hasActive = function() {
      return this.activeObservations_.length > 0;
    };
    return ResizeObserverSPI2;
  }()
);
var observers = typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : new MapShim();
var ResizeObserver = (
  /** @class */
  /* @__PURE__ */ function() {
    function ResizeObserver2(callback) {
      if (!(this instanceof ResizeObserver2)) {
        throw new TypeError("Cannot call a class as a function.");
      }
      if (!arguments.length) {
        throw new TypeError("1 argument required, but only 0 present.");
      }
      var controller = ResizeObserverController.getInstance();
      var observer = new ResizeObserverSPI(callback, controller, this);
      observers.set(this, observer);
    }
    return ResizeObserver2;
  }()
);
[
  "observe",
  "unobserve",
  "disconnect"
].forEach(function(method) {
  ResizeObserver.prototype[method] = function() {
    var _a;
    return (_a = observers.get(this))[method].apply(_a, arguments);
  };
});
var index = function() {
  if (typeof global$1.ResizeObserver !== "undefined") {
    return global$1.ResizeObserver;
  }
  return ResizeObserver;
}();
var ResizeObserver_es_default = index;

// node_modules/react-canvas-draw/es/coordinateSystem.js
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  return Constructor;
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var NULL_VIEW_POINT = Object.freeze({
  x: 0,
  y: 0,
  untransformedX: 0,
  untransformedY: 0
});
var NULL_BOUNDS = Object.freeze({
  canvasWidth: 0,
  canvasHeight: 0,
  left: 0,
  top: 0,
  right: 0,
  bottom: 0,
  viewMin: NULL_VIEW_POINT,
  viewMax: NULL_VIEW_POINT
});
var IDENTITY = Object.freeze({
  a: 1,
  b: 0,
  c: 0,
  d: 1,
  e: 0,
  f: 0
});
var CoordinateSystem = function() {
  function CoordinateSystem2(_ref) {
    var _this2 = this;
    var scaleExtents = _ref.scaleExtents, documentSize = _ref.documentSize;
    _defineProperty(this, "_scaleExtents", void 0);
    _defineProperty(this, "_documentSize", void 0);
    _defineProperty(this, "_canvas", null);
    _defineProperty(this, "_view", {
      scale: 1,
      x: 0,
      y: 0
    });
    _defineProperty(this, "_viewChangeListeners", /* @__PURE__ */ new Set());
    _defineProperty(this, "setScale", function(scale) {
      _this2.setView({
        scale
      });
    });
    _defineProperty(this, "clampView", function(_ref2) {
      var scale = _ref2.scale, x = _ref2.x, y = _ref2.y;
      var _this$scaleExtents = _this2.scaleExtents, min = _this$scaleExtents.min, max = _this$scaleExtents.max;
      var _this$documentSize = _this2.documentSize, width = _this$documentSize.width, height = _this$documentSize.height;
      var _ref3 = _this2.canvasRect || NULL_BOUNDS, left = _ref3.left, top = _ref3.top, right = _ref3.right, bottom = _ref3.bottom;
      var canvasWidth = right - left;
      var canvasHeight = bottom - top;
      var maxx = canvasWidth / 2;
      var minx = -(width * _this2._view.scale - canvasWidth / 2);
      var maxy = canvasHeight / 2;
      var miny = -(height * _this2._view.scale - canvasHeight / 2);
      return {
        scale: Math.min(Math.max(scale, min), max),
        x: Math.min(Math.max(x, minx), maxx),
        y: Math.min(Math.max(y, miny), maxy)
      };
    });
    _defineProperty(this, "resetView", function() {
      _this2.setView({
        scale: 1,
        x: 0,
        y: 0
      });
    });
    _defineProperty(this, "setView", function(view) {
      var newView = _this2.clampView(_extends({}, _this2._view, view || {}));
      var _this$_view = _this2._view, scale = _this$_view.scale, x = _this$_view.x, y = _this$_view.y;
      if (newView.scale !== scale || newView.x !== x || newView.y !== y) {
        _this2._view = newView;
        _this2._viewChangeListeners.forEach(function(listener) {
          return listener && listener(newView);
        });
      }
      return _extends({}, _this2._view);
    });
    _defineProperty(this, "scaleAtClientPoint", function(deltaScale, clientPoint) {
      var viewPt = _this2.clientPointToViewPoint(clientPoint);
      var newView = _this2.clampView(_extends({}, _this2._view, {
        scale: _this2._view.scale + deltaScale
      }));
      var clientPtPostScale = _this2.viewPointToClientPoint(viewPt, newView);
      newView.x = _this2._view.x - (clientPtPostScale.clientX - clientPoint.clientX);
      newView.y = _this2._view.y - (clientPtPostScale.clientY - clientPoint.clientY);
      return _this2.setView(newView);
    });
    _defineProperty(this, "clientPointToViewPoint", function(_ref4, view) {
      var clientX = _ref4.clientX, clientY = _ref4.clientY;
      if (view === void 0) {
        view = _this2._view;
      }
      var _ref5 = _this2.canvasRect || NULL_BOUNDS, left = _ref5.left, top = _ref5.top;
      var relativeClientX = clientX - left;
      var relativeClientY = clientY - top;
      return {
        x: (relativeClientX - view.x) / view.scale,
        y: (relativeClientY - view.y) / view.scale,
        relativeClientX,
        relativeClientY
      };
    });
    _defineProperty(this, "viewPointToClientPoint", function(_ref6, view) {
      var x = _ref6.x, y = _ref6.y;
      if (view === void 0) {
        view = _this2._view;
      }
      var _ref7 = _this2.canvasRect || NULL_BOUNDS, left = _ref7.left, top = _ref7.top;
      var relativeX = x * view.scale + view.x;
      var relativeY = y * view.scale + view.y;
      var clientX = relativeX + left;
      var clientY = relativeY + top;
      return {
        clientX,
        clientY,
        relativeX,
        relativeY,
        x: clientX,
        y: clientY
      };
    });
    _defineProperty(this, "attachViewChangeListener", function(listener) {
      _this2._viewChangeListeners.add(listener);
    });
    this._scaleExtents = scaleExtents;
    this._documentSize = documentSize;
  }
  _createClass(CoordinateSystem2, [{
    key: "canvas",
    /**
     * @returns {Canvas} the canvas currently associated with this instance.
     */
    get: function get() {
      return this._canvas;
    },
    set: function set(canvas) {
      this._canvas = canvas;
      this.setView();
    }
    /**
     * @returns {number} the current zoom factor
     */
  }, {
    key: "scale",
    get: function get() {
      return this._view.scale;
    }
    /**
     * Sets the zoom factor (clamped by the scale extents) and updates the view.
     * @param {number} the new zoom factor
     */
  }, {
    key: "x",
    /**
     * @returns {number} the horizontal component of the current pan offset
     */
    get: function get() {
      return this._view.x;
    },
    set: function set(x) {
      this.setView({
        x
      });
    }
    /**
     * @retruns {number} the vertical component of the current pan offset
     */
  }, {
    key: "y",
    get: function get() {
      return this._view.y;
    },
    set: function set(y) {
      this.setView({
        y
      });
    }
    /**
     * @returns {View} a copy of this instance's current view state.
     */
  }, {
    key: "view",
    get: function get() {
      return _extends({}, this._view);
    }
    /**
     * @returns {Extents} a copy of the scale extents currently applied to this
     * instance.
     */
  }, {
    key: "scaleExtents",
    get: function get() {
      return _extends({}, this._scaleExtents);
    },
    set: function set(_ref8) {
      var min = _ref8.min, max = _ref8.max;
      this._scaleExtents = {
        min,
        max
      };
      this.setView();
    }
    /**
     * @returns {Size} the current document size (used to constrain the pan
     * offset).
     */
  }, {
    key: "documentSize",
    get: function get() {
      return _extends({}, this._documentSize);
    },
    set: function set(_ref9) {
      var width = _ref9.width, height = _ref9.height;
      this._documentSize = {
        width,
        height
      };
      this.setView();
    }
    /**
     * A view matrix expressing a series of transformations.
     * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/setTransform
     * @typedef Matrix
     * @property {number} a horizontal scaling factor (1 == unscaled)
     * @property {number} b vertical skewing factor (0 == unskewed)
     * @property {number} c horizontal skewing factor (0 == unskewed)
     * @property {number} d vertical scaling factor (1 == unscaled)
     * @property {number} e horizontal translation (0 == untranslated)
     * @property {number} f vertical translation (0 == untranslated)
     */
    /**
     * @returns {Matrix} this coordinate system's current transformation matrix
     */
  }, {
    key: "transformMatrix",
    get: function get() {
      return {
        a: this._view.scale,
        // horizontal scaling
        b: 0,
        // vertical skewing
        c: 0,
        // horizontal skewing
        d: this._view.scale,
        // vertical scaling
        e: this._view.x,
        f: this._view.y
      };
    }
    /**
     * An object expressing the bounds of a canvas object in terms of the
     * coordinate system.
     * @typedef CanvasBounds
     * @property {number} left the left edge of the canvas in client space
     * @property {number} right the right edge of the canvas in client space
     * @property {number} top the top edge of the canvas in client space
     * @property {number} bottom the bottom edge of the canvas in client space
     * @property {number} canvasWidth the width of the canvas in client space
     * @property {number} canvasHeight the height of the canvas in client space
     * @property {ViewPoint} viewMin the top-left corner of the canvas in view space
     * @property {ViewPoint} viewMax the bottom-right corner of the canvas in view space
     */
    /**
     * @returns {CanvasBounds | undefined} the boundaries of the canvas linked to
     * this coordinate system, or undefined if no canvas is set.
     */
  }, {
    key: "canvasBounds",
    get: function get() {
      if (this._canvas) {
        var _this$_canvas$getBoun = this._canvas.getBoundingClientRect(), left = _this$_canvas$getBoun.left, top = _this$_canvas$getBoun.top, right = _this$_canvas$getBoun.right, bottom = _this$_canvas$getBoun.bottom;
        return {
          viewMin: this.clientPointToViewPoint({
            clientX: left,
            clientY: top
          }),
          viewMax: this.clientPointToViewPoint({
            clientX: right,
            clientY: bottom
          }),
          left,
          top,
          right,
          bottom,
          canvasWidth: this._canvas.width,
          canvasHeight: this._canvas.height
        };
      } else {
        return void 0;
      }
    }
    /**
     * @private
     * @return {{left: number, top: number} | undefined}
     */
  }, {
    key: "canvasRect",
    get: function get() {
      if (this.canvas) {
        return this.canvas.getBoundingClientRect();
      } else {
        return void 0;
      }
    }
    /**
     * Calculates a variant of the given view clamped according to the scale and
     * document bounds. Does not modify this instance.
     * @param {View} view the view constraints to clamp.
     * @returns {View} a new view object representing the constrained input.
     */
  }]);
  return CoordinateSystem2;
}();

// node_modules/react-canvas-draw/es/drawImage.js
function drawImageProp(_temp) {
  var _ref = _temp === void 0 ? {} : _temp, ctx = _ref.ctx, img = _ref.img, x = _ref.x, y = _ref.y, w = _ref.w, h = _ref.h, offsetX = _ref.offsetX, offsetY = _ref.offsetY;
  if (typeof x !== "number")
    x = 0;
  if (typeof y !== "number")
    y = 0;
  if (typeof w !== "number")
    w = ctx.canvas.width;
  if (typeof h !== "number")
    h = ctx.canvas.height;
  if (typeof offsetX !== "number")
    offsetX = 0.5;
  if (typeof offsetY !== "number")
    offsetY = 0.5;
  if (offsetX < 0)
    offsetX = 0;
  if (offsetY < 0)
    offsetY = 0;
  if (offsetX > 1)
    offsetX = 1;
  if (offsetY > 1)
    offsetY = 1;
  var iw = img.width, ih = img.height, r = Math.min(w / iw, h / ih), nw = iw * r, nh = ih * r, cx, cy, cw, ch, ar = 1;
  if (nw < w)
    ar = w / nw;
  if (Math.abs(ar - 1) < 1e-14 && nh < h)
    ar = h / nh;
  nw *= ar;
  nh *= ar;
  cw = iw / (nw / w);
  ch = ih / (nh / h);
  cx = (iw - cw) * offsetX;
  cy = (ih - ch) * offsetY;
  if (cx < 0)
    cx = 0;
  if (cy < 0)
    cy = 0;
  if (cw > iw)
    cw = iw;
  if (ch > ih)
    ch = ih;
  ctx.drawImage(img, cx, cy, cw, ch, x, y, w, h);
}

// node_modules/react-canvas-draw/es/interactionStateMachine.js
var _this = void 0;
function _defineProperty2(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var TOUCH_SLOP = 10;
var PINCH_TIMEOUT_MS = 250;
var SUPPRESS_SCROLL = function SUPPRESS_SCROLL2(e) {
  e.preventDefault();
  return _this;
};
var DefaultState = function DefaultState2() {
  var _this2 = this;
  _defineProperty2(this, "handleMouseWheel", function(e, canvasDraw) {
    var _canvasDraw$props = canvasDraw.props, disabled = _canvasDraw$props.disabled, enablePanAndZoom = _canvasDraw$props.enablePanAndZoom, mouseZoomFactor = _canvasDraw$props.mouseZoomFactor;
    if (disabled) {
      return new DisabledState();
    } else if (enablePanAndZoom && e.ctrlKey) {
      e.preventDefault();
      canvasDraw.coordSystem.scaleAtClientPoint(mouseZoomFactor * e.deltaY, clientPointFromEvent(e));
    }
    return _this2;
  });
  _defineProperty2(this, "handleDrawStart", function(e, canvasDraw) {
    if (canvasDraw.props.disabled) {
      return new DisabledState();
    } else if (e.ctrlKey && canvasDraw.props.enablePanAndZoom) {
      return new PanState().handleDrawStart(e, canvasDraw);
    } else {
      return new WaitForPinchState().handleDrawStart(e, canvasDraw);
    }
  });
  _defineProperty2(this, "handleDrawMove", function(e, canvasDraw) {
    if (canvasDraw.props.disabled) {
      return new DisabledState();
    } else {
      var _viewPointFromEvent = viewPointFromEvent(canvasDraw.coordSystem, e), x = _viewPointFromEvent.x, y = _viewPointFromEvent.y;
      canvasDraw.lazy.update({
        x,
        y
      });
      return _this2;
    }
  });
  _defineProperty2(this, "handleDrawEnd", function(e, canvasDraw) {
    return canvasDraw.props.disabled ? new DisabledState() : _this2;
  });
};
var DisabledState = function DisabledState2() {
  var _this3 = this;
  _defineProperty2(this, "handleMouseWheel", function(e, canvasDraw) {
    if (canvasDraw.props.disabled) {
      return _this3;
    } else {
      return new DefaultState().handleMouseWheel(e, canvasDraw);
    }
  });
  _defineProperty2(this, "handleDrawStart", function(e, canvasDraw) {
    if (canvasDraw.props.disabled) {
      return _this3;
    } else {
      return new DefaultState().handleDrawStart(e, canvasDraw);
    }
  });
  _defineProperty2(this, "handleDrawMove", function(e, canvasDraw) {
    if (canvasDraw.props.disabled) {
      return _this3;
    } else {
      return new DefaultState().handleDrawMove(e, canvasDraw);
    }
  });
  _defineProperty2(this, "handleDrawEnd", function(e, canvasDraw) {
    if (canvasDraw.props.disabled) {
      return _this3;
    } else {
      return new DefaultState().handleDrawEnd(e, canvasDraw);
    }
  });
};
var PanState = function PanState2() {
  var _this4 = this;
  _defineProperty2(this, "handleMouseWheel", SUPPRESS_SCROLL.bind(this));
  _defineProperty2(this, "handleDrawStart", function(e, canvasDraw) {
    e.preventDefault();
    _this4.dragStart = clientPointFromEvent(e);
    _this4.panStart = {
      x: canvasDraw.coordSystem.x,
      y: canvasDraw.coordSystem.y
    };
    return _this4;
  });
  _defineProperty2(this, "handleDrawMove", function(e, canvasDraw) {
    e.preventDefault();
    var _clientPointFromEvent = clientPointFromEvent(e), clientX = _clientPointFromEvent.clientX, clientY = _clientPointFromEvent.clientY;
    var dx = clientX - _this4.dragStart.clientX;
    var dy = clientY - _this4.dragStart.clientY;
    canvasDraw.coordSystem.setView({
      x: _this4.panStart.x + dx,
      y: _this4.panStart.y + dy
    });
    return _this4;
  });
  _defineProperty2(this, "handleDrawEnd", function() {
    return new DefaultState();
  });
};
var WaitForPinchState = function WaitForPinchState2() {
  var _this5 = this;
  _defineProperty2(this, "handleMouseWheel", SUPPRESS_SCROLL.bind(this));
  _defineProperty2(this, "handleDrawStart", function(e, canvasDraw) {
    var enablePanAndZoom = canvasDraw.props.enablePanAndZoom;
    e.preventDefault();
    if (!e.touches || !e.touches.length || !enablePanAndZoom) {
      return new DrawingState().handleDrawStart(e, canvasDraw);
    }
    if (enablePanAndZoom && e.touches && e.touches.length >= 2) {
      return new ScaleOrPanState().handleDrawStart(e, canvasDraw);
    }
    return _this5.handleDrawMove(e, canvasDraw);
  });
  _defineProperty2(this, "handleDrawMove", function(e, canvasDraw) {
    e.preventDefault();
    if (e.touches && e.touches.length >= 2) {
      return new ScaleOrPanState().handleDrawStart(e, canvasDraw);
    }
    var clientPt = clientPointFromEvent(e);
    _this5.deferredPoints.push(clientPt);
    if ((/* @__PURE__ */ new Date()).valueOf() - _this5.startTimestamp < PINCH_TIMEOUT_MS) {
      if (_this5.startClientPoint === null) {
        _this5.startClientPoint = clientPt;
      }
      var d = Math.abs(clientPt.clientX - _this5.startClientPoint.clientX) + Math.abs(clientPt.clientY - _this5.startClientPoint.clientY);
      if (d < TOUCH_SLOP) {
        return _this5;
      }
    }
    return _this5.issueDeferredPoints(canvasDraw);
  });
  _defineProperty2(this, "handleDrawEnd", function(e, canvasDraw) {
    return _this5.issueDeferredPoints(canvasDraw).handleDrawEnd(e, canvasDraw);
  });
  _defineProperty2(this, "issueDeferredPoints", function(canvasDraw) {
    var nextState = new DrawingState();
    for (var i = 0; i < _this5.deferredPoints.length; i++) {
      var deferredPt = _this5.deferredPoints[i];
      var syntheticEvt = new SyntheticEvent(deferredPt);
      var func = i === 0 ? nextState.handleDrawStart : nextState.handleDrawMove;
      nextState = func(syntheticEvt, canvasDraw);
    }
    return nextState;
  });
  this.startClientPoint = null;
  this.startTimestamp = (/* @__PURE__ */ new Date()).valueOf();
  this.deferredPoints = [];
};
var ScaleOrPanState = function ScaleOrPanState2() {
  var _this6 = this;
  _defineProperty2(this, "handleMouseWheel", SUPPRESS_SCROLL.bind(this));
  _defineProperty2(this, "handleDrawStart", function(e, canvasDraw) {
    e.preventDefault();
    if (!e.touches || e.touches.length < 2) {
      return new DefaultState();
    }
    _this6.start = _this6.getTouchMetrics(e);
    _this6.panStart = {
      x: canvasDraw.coordSystem.x,
      y: canvasDraw.coordSystem.y
    };
    _this6.scaleStart = canvasDraw.coordSystem.scale;
    return _this6;
  });
  _defineProperty2(this, "handleDrawMove", function(e, canvasDraw) {
    e.preventDefault();
    if (!e.touches || e.touches.length < 2) {
      return new DefaultState();
    }
    var _this6$recentMetrics = _this6.recentMetrics = _this6.getTouchMetrics(e), centroid = _this6$recentMetrics.centroid, distance = _this6$recentMetrics.distance;
    var dd = Math.abs(distance - _this6.start.distance);
    if (dd >= TOUCH_SLOP) {
      return new TouchScaleState(_this6).handleDrawMove(e, canvasDraw);
    }
    var dx = centroid.clientX - _this6.start.centroid.clientX;
    var dy = centroid.clientY - _this6.start.centroid.clientY;
    var dc = Math.abs(dx) + Math.abs(dy);
    if (dc >= TOUCH_SLOP) {
      return new TouchPanState(_this6).handleDrawMove(e, canvasDraw);
    }
    return _this6;
  });
  _defineProperty2(this, "handleDrawEnd", function() {
    return new DefaultState();
  });
  _defineProperty2(this, "getTouchMetrics", function(e) {
    var _clientPointFromEvent2 = clientPointFromEvent(e.touches[0]), t1x = _clientPointFromEvent2.clientX, t1y = _clientPointFromEvent2.clientY;
    var _clientPointFromEvent3 = clientPointFromEvent(e.touches[1]), t2x = _clientPointFromEvent3.clientX, t2y = _clientPointFromEvent3.clientY;
    var dx = t2x - t1x;
    var dy = t2y - t1y;
    return {
      t1: {
        clientX: t1x,
        clientY: t1y
      },
      t2: {
        clientX: t2x,
        clientY: t2y
      },
      distance: Math.sqrt(dx * dx + dy * dy),
      centroid: {
        clientX: (t1x + t2x) / 2,
        clientY: (t1y + t2y) / 2
      }
    };
  });
};
var TouchPanState = function TouchPanState2(scaleOrPanState) {
  var _this7 = this;
  _defineProperty2(this, "handleMouseWheel", SUPPRESS_SCROLL.bind(this));
  _defineProperty2(this, "handleDrawStart", function() {
    return _this7;
  });
  _defineProperty2(this, "handleDrawMove", function(e, canvasDraw) {
    e.preventDefault();
    if (!e.touches || e.touches.length < 2) {
      return new DefaultState();
    }
    var ref = _this7.scaleOrPanState;
    var _ref$recentMetrics = ref.recentMetrics = ref.getTouchMetrics(e), centroid = _ref$recentMetrics.centroid, distance = _ref$recentMetrics.distance;
    var dx = centroid.clientX - ref.start.centroid.clientX;
    var dy = centroid.clientY - ref.start.centroid.clientY;
    canvasDraw.setView({
      x: ref.panStart.x + dx,
      y: ref.panStart.y + dy
    });
    return _this7;
  });
  _defineProperty2(this, "handleDrawEnd", function() {
    return new DefaultState();
  });
  this.scaleOrPanState = scaleOrPanState;
};
var TouchScaleState = function TouchScaleState2(scaleOrPanState) {
  var _this8 = this;
  _defineProperty2(this, "handleMouseWheel", SUPPRESS_SCROLL.bind(this));
  _defineProperty2(this, "handleDrawStart", function() {
    return _this8;
  });
  _defineProperty2(this, "handleDrawMove", function(e, canvasDraw) {
    e.preventDefault();
    if (!e.touches || e.touches.length < 2) {
      return new DefaultState();
    }
    var ref = _this8.scaleOrPanState;
    var _ref$recentMetrics2 = ref.recentMetrics = ref.getTouchMetrics(e), centroid = _ref$recentMetrics2.centroid, distance = _ref$recentMetrics2.distance;
    var targetScale = ref.scaleStart * (distance / ref.start.distance);
    var dScale = targetScale - canvasDraw.coordSystem.scale;
    canvasDraw.coordSystem.scaleAtClientPoint(dScale, centroid);
    return _this8;
  });
  _defineProperty2(this, "handleDrawEnd", function() {
    return new DefaultState();
  });
  this.scaleOrPanState = scaleOrPanState;
};
var DrawingState = function DrawingState2() {
  var _this9 = this;
  _defineProperty2(this, "handleMouseWheel", SUPPRESS_SCROLL.bind(this));
  _defineProperty2(this, "handleDrawStart", function(e, canvasDraw) {
    e.preventDefault();
    if (e.touches && e.touches.length) {
      var _viewPointFromEvent2 = viewPointFromEvent(canvasDraw.coordSystem, e), x = _viewPointFromEvent2.x, y = _viewPointFromEvent2.y;
      canvasDraw.lazy.update({
        x,
        y
      }, {
        both: true
      });
    }
    return _this9.handleDrawMove(e, canvasDraw);
  });
  _defineProperty2(this, "handleDrawMove", function(e, canvasDraw) {
    e.preventDefault();
    var _viewPointFromEvent3 = viewPointFromEvent(canvasDraw.coordSystem, e), x = _viewPointFromEvent3.x, y = _viewPointFromEvent3.y;
    canvasDraw.lazy.update({
      x,
      y
    });
    var isDisabled = !canvasDraw.lazy.isEnabled();
    if (!_this9.isDrawing || isDisabled) {
      canvasDraw.points.push(canvasDraw.clampPointToDocument(canvasDraw.lazy.brush.toObject()));
      _this9.isDrawing = true;
    }
    canvasDraw.points.push(canvasDraw.clampPointToDocument(canvasDraw.lazy.brush.toObject()));
    canvasDraw.drawPoints({
      points: canvasDraw.points,
      brushColor: canvasDraw.props.brushColor,
      brushRadius: canvasDraw.props.brushRadius
    });
    return _this9;
  });
  _defineProperty2(this, "handleDrawEnd", function(e, canvasDraw) {
    e.preventDefault();
    _this9.handleDrawMove(e, canvasDraw);
    canvasDraw.saveLine();
    return new DefaultState();
  });
  this.isDrawing = false;
};
var SyntheticEvent = function SyntheticEvent2(_ref) {
  var clientX = _ref.clientX, clientY = _ref.clientY;
  _defineProperty2(this, "preventDefault", function() {
  });
  this.clientX = clientX;
  this.clientY = clientY;
  this.touches = [{
    clientX,
    clientY
  }];
};
function clientPointFromEvent(e) {
  var clientX = e.clientX;
  var clientY = e.clientY;
  if (e.changedTouches && e.changedTouches.length > 0) {
    clientX = e.changedTouches[0].clientX;
    clientY = e.changedTouches[0].clientY;
  }
  return {
    clientX,
    clientY
  };
}
function viewPointFromEvent(coordSystem, e) {
  return coordSystem.clientPointToViewPoint(clientPointFromEvent(e));
}

// node_modules/react-canvas-draw/es/makePassiveEventOption.js
var passiveSupported = false;
try {
  options = {
    get passive() {
      passiveSupported = true;
      return false;
    }
  };
  window.addEventListener("test", options, options);
  window.removeEventListener("test", options, options);
} catch (e) {
  passiveSupported = false;
}
var options;
function makePassiveEventOption(passive) {
  return passiveSupported ? {
    passive
  } : passive;
}

// node_modules/react-canvas-draw/es/index.js
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it;
  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it)
        o = it;
      var i = 0;
      return function() {
        if (i >= o.length)
          return { done: true };
        return { done: false, value: o[i++] };
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  it = o[Symbol.iterator]();
  return it.next.bind(it);
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _extends2() {
  _extends2 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends2.apply(this, arguments);
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
function _defineProperty3(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function midPointBtw(p1, p2) {
  return {
    x: p1.x + (p2.x - p1.x) / 2,
    y: p1.y + (p2.y - p1.y) / 2
  };
}
var canvasStyle = {
  display: "block",
  position: "absolute"
};
var canvasTypes = ["grid", "drawing", "temp", "interface"];
var dimensionsPropTypes = true ? import_prop_types.default.oneOfType([import_prop_types.default.number, import_prop_types.default.string]) : {};
var boundsProp = true ? import_prop_types.default.shape({
  min: import_prop_types.default.number.isRequired,
  max: import_prop_types.default.number.isRequired
}) : {};
var CanvasDraw = function(_PureComponent) {
  _inheritsLoose(CanvasDraw2, _PureComponent);
  function CanvasDraw2(props) {
    var _this2;
    _this2 = _PureComponent.call(this, props) || this;
    _defineProperty3(_assertThisInitialized(_this2), "undo", function() {
      var lines = [];
      if (_this2.lines.length) {
        lines = _this2.lines.slice(0, -1);
      } else if (_this2.erasedLines.length) {
        lines = _this2.erasedLines.pop();
      }
      _this2.clearExceptErasedLines();
      _this2.simulateDrawingLines({
        lines,
        immediate: true
      });
      _this2.triggerOnChange();
    });
    _defineProperty3(_assertThisInitialized(_this2), "eraseAll", function() {
      _this2.erasedLines.push([].concat(_this2.lines));
      _this2.clearExceptErasedLines();
      _this2.triggerOnChange();
    });
    _defineProperty3(_assertThisInitialized(_this2), "clear", function() {
      _this2.erasedLines = [];
      _this2.clearExceptErasedLines();
      _this2.resetView();
    });
    _defineProperty3(_assertThisInitialized(_this2), "resetView", function() {
      return _this2.coordSystem.resetView();
    });
    _defineProperty3(_assertThisInitialized(_this2), "setView", function(view) {
      return _this2.coordSystem.setView(view);
    });
    _defineProperty3(_assertThisInitialized(_this2), "getSaveData", function() {
      return JSON.stringify({
        lines: _this2.lines,
        width: _this2.props.canvasWidth,
        height: _this2.props.canvasHeight
      });
    });
    _defineProperty3(_assertThisInitialized(_this2), "getDataURL", function(fileType, useBgImage, backgroundColour) {
      var canvasToExport = _this2.canvas.drawing;
      var context = canvasToExport.getContext("2d");
      var width = canvasToExport.width;
      var height = canvasToExport.height;
      var storedImageData = context.getImageData(0, 0, width, height);
      var compositeOperation = context.globalCompositeOperation;
      context.globalCompositeOperation = "destination-over";
      if (useBgImage) {
        if (!_this2.props.imgSrc)
          return "Background image source not set";
        _this2.drawImage();
      } else if (backgroundColour != null) {
        context.fillStyle = backgroundColour;
        context.fillRect(0, 0, width, height);
      }
      if (!fileType)
        fileType = "png";
      var imageData = canvasToExport.toDataURL("image/" + fileType);
      context.clearRect(0, 0, width, height);
      context.putImageData(storedImageData, 0, 0);
      context.globalCompositeOperation = compositeOperation;
      return imageData;
    });
    _defineProperty3(_assertThisInitialized(_this2), "loadSaveData", function(saveData, immediate) {
      if (immediate === void 0) {
        immediate = _this2.props.immediateLoading;
      }
      if (typeof saveData !== "string") {
        throw new Error("saveData needs to be of type string!");
      }
      var _JSON$parse = JSON.parse(saveData), lines = _JSON$parse.lines, width = _JSON$parse.width, height = _JSON$parse.height;
      if (!lines || typeof lines.push !== "function") {
        throw new Error("saveData.lines needs to be an array!");
      }
      _this2.clear();
      if (width === _this2.props.canvasWidth && height === _this2.props.canvasHeight) {
        _this2.simulateDrawingLines({
          lines,
          immediate
        });
      } else {
        var scaleX = _this2.props.canvasWidth / width;
        var scaleY = _this2.props.canvasHeight / height;
        var scaleAvg = (scaleX + scaleY) / 2;
        _this2.simulateDrawingLines({
          lines: lines.map(function(line) {
            return _extends2({}, line, {
              points: line.points.map(function(p) {
                return {
                  x: p.x * scaleX,
                  y: p.y * scaleY
                };
              }),
              brushRadius: line.brushRadius * scaleAvg
            });
          }),
          immediate
        });
      }
    });
    _defineProperty3(_assertThisInitialized(_this2), "componentWillUnmount", function() {
      _this2.canvasObserver.unobserve(_this2.canvasContainer);
      _this2.canvas["interface"] && _this2.canvas["interface"].removeEventListener("wheel", _this2.handleWheel);
    });
    _defineProperty3(_assertThisInitialized(_this2), "handleWheel", function(e) {
      _this2.interactionSM = _this2.interactionSM.handleMouseWheel(e, _assertThisInitialized(_this2));
    });
    _defineProperty3(_assertThisInitialized(_this2), "handleDrawStart", function(e) {
      _this2.interactionSM = _this2.interactionSM.handleDrawStart(e, _assertThisInitialized(_this2));
      _this2.mouseHasMoved = true;
    });
    _defineProperty3(_assertThisInitialized(_this2), "handleDrawMove", function(e) {
      _this2.interactionSM = _this2.interactionSM.handleDrawMove(e, _assertThisInitialized(_this2));
      _this2.mouseHasMoved = true;
    });
    _defineProperty3(_assertThisInitialized(_this2), "handleDrawEnd", function(e) {
      _this2.interactionSM = _this2.interactionSM.handleDrawEnd(e, _assertThisInitialized(_this2));
      _this2.mouseHasMoved = true;
    });
    _defineProperty3(_assertThisInitialized(_this2), "applyView", function() {
      if (!_this2.ctx.drawing) {
        return;
      }
      canvasTypes.map(function(name) {
        return _this2.ctx[name];
      }).forEach(function(ctx) {
        _this2.clearWindow(ctx);
        var m = _this2.coordSystem.transformMatrix;
        ctx.setTransform(m.a, m.b, m.c, m.d, m.e, m.f);
      });
      if (!_this2.deferRedrawOnViewChange) {
        _this2.drawGrid(_this2.ctx.grid);
        _this2.redrawImage();
        _this2.loop({
          once: true
        });
        var lines = _this2.lines;
        _this2.lines = [];
        _this2.simulateDrawingLines({
          lines,
          immediate: true
        });
      }
    });
    _defineProperty3(_assertThisInitialized(_this2), "handleCanvasResize", function(entries) {
      var saveData = _this2.getSaveData();
      _this2.deferRedrawOnViewChange = true;
      try {
        for (var _iterator = _createForOfIteratorHelperLoose(entries), _step; !(_step = _iterator()).done; ) {
          var entry = _step.value;
          var _entry$contentRect = entry.contentRect, width = _entry$contentRect.width, height = _entry$contentRect.height;
          _this2.setCanvasSize(_this2.canvas["interface"], width, height);
          _this2.setCanvasSize(_this2.canvas.drawing, width, height);
          _this2.setCanvasSize(_this2.canvas.temp, width, height);
          _this2.setCanvasSize(_this2.canvas.grid, width, height);
          _this2.coordSystem.documentSize = {
            width,
            height
          };
          _this2.drawGrid(_this2.ctx.grid);
          _this2.drawImage();
          _this2.loop({
            once: true
          });
        }
        _this2.loadSaveData(saveData, true);
      } finally {
        _this2.deferRedrawOnViewChange = false;
      }
    });
    _defineProperty3(_assertThisInitialized(_this2), "clampPointToDocument", function(point) {
      if (_this2.props.clampLinesToDocument) {
        return {
          x: Math.max(Math.min(point.x, _this2.props.canvasWidth), 0),
          y: Math.max(Math.min(point.y, _this2.props.canvasHeight), 0)
        };
      } else {
        return point;
      }
    });
    _defineProperty3(_assertThisInitialized(_this2), "redrawImage", function() {
      _this2.image && _this2.image.complete && drawImageProp({
        ctx: _this2.ctx.grid,
        img: _this2.image
      });
    });
    _defineProperty3(_assertThisInitialized(_this2), "simulateDrawingLines", function(_ref) {
      var lines = _ref.lines, immediate = _ref.immediate;
      var curTime = 0;
      var timeoutGap = immediate ? 0 : _this2.props.loadTimeOffset;
      lines.forEach(function(line) {
        var points = line.points, brushColor = line.brushColor, brushRadius = line.brushRadius;
        if (immediate) {
          _this2.drawPoints({
            points,
            brushColor,
            brushRadius
          });
          _this2.points = points;
          _this2.saveLine({
            brushColor,
            brushRadius
          });
          return;
        }
        var _loop = function _loop2(i2) {
          curTime += timeoutGap;
          window.setTimeout(function() {
            _this2.drawPoints({
              points: points.slice(0, i2 + 1),
              brushColor,
              brushRadius
            });
          }, curTime);
        };
        for (var i = 1; i < points.length; i++) {
          _loop(i);
        }
        curTime += timeoutGap;
        window.setTimeout(function() {
          _this2.points = points;
          _this2.saveLine({
            brushColor,
            brushRadius
          });
        }, curTime);
      });
    });
    _defineProperty3(_assertThisInitialized(_this2), "setCanvasSize", function(canvas, width, height) {
      canvas.width = width;
      canvas.height = height;
      canvas.style.width = width;
      canvas.style.height = height;
    });
    _defineProperty3(_assertThisInitialized(_this2), "drawPoints", function(_ref2) {
      var points = _ref2.points, brushColor = _ref2.brushColor, brushRadius = _ref2.brushRadius;
      _this2.ctx.temp.lineJoin = "round";
      _this2.ctx.temp.lineCap = "round";
      _this2.ctx.temp.strokeStyle = brushColor;
      _this2.clearWindow(_this2.ctx.temp);
      _this2.ctx.temp.lineWidth = brushRadius * 2;
      var p1 = points[0];
      var p2 = points[1];
      _this2.ctx.temp.moveTo(p2.x, p2.y);
      _this2.ctx.temp.beginPath();
      for (var i = 1, len = points.length; i < len; i++) {
        var midPoint = midPointBtw(p1, p2);
        _this2.ctx.temp.quadraticCurveTo(p1.x, p1.y, midPoint.x, midPoint.y);
        p1 = points[i];
        p2 = points[i + 1];
      }
      _this2.ctx.temp.lineTo(p1.x, p1.y);
      _this2.ctx.temp.stroke();
    });
    _defineProperty3(_assertThisInitialized(_this2), "saveLine", function(_temp) {
      var _ref3 = _temp === void 0 ? {} : _temp, brushColor = _ref3.brushColor, brushRadius = _ref3.brushRadius;
      if (_this2.points.length < 2)
        return;
      _this2.lines.push({
        points: [].concat(_this2.points),
        brushColor: brushColor || _this2.props.brushColor,
        brushRadius: brushRadius || _this2.props.brushRadius
      });
      _this2.points.length = 0;
      _this2.inClientSpace([_this2.ctx.drawing, _this2.ctx.temp], function() {
        _this2.ctx.drawing.drawImage(_this2.canvas.temp, 0, 0, _this2.canvas.drawing.width, _this2.canvas.drawing.height);
      });
      _this2.clearWindow(_this2.ctx.temp);
      _this2.triggerOnChange();
    });
    _defineProperty3(_assertThisInitialized(_this2), "triggerOnChange", function() {
      _this2.props.onChange && _this2.props.onChange(_assertThisInitialized(_this2));
    });
    _defineProperty3(_assertThisInitialized(_this2), "clearWindow", function(ctx) {
      _this2.inClientSpace([ctx], function() {
        return ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
      });
    });
    _defineProperty3(_assertThisInitialized(_this2), "clearExceptErasedLines", function() {
      _this2.lines = [];
      _this2.valuesChanged = true;
      _this2.clearWindow(_this2.ctx.drawing);
      _this2.clearWindow(_this2.ctx.temp);
    });
    _defineProperty3(_assertThisInitialized(_this2), "loop", function(_temp2) {
      var _ref4 = _temp2 === void 0 ? {} : _temp2, _ref4$once = _ref4.once, once = _ref4$once === void 0 ? false : _ref4$once;
      if (_this2.mouseHasMoved || _this2.valuesChanged) {
        var pointer = _this2.lazy.getPointerCoordinates();
        var brush = _this2.lazy.getBrushCoordinates();
        _this2.drawInterface(_this2.ctx["interface"], pointer, brush);
        _this2.mouseHasMoved = false;
        _this2.valuesChanged = false;
      }
      if (!once) {
        window.requestAnimationFrame(function() {
          _this2.loop();
        });
      }
    });
    _defineProperty3(_assertThisInitialized(_this2), "inClientSpace", function(ctxs, action) {
      ctxs.forEach(function(ctx) {
        ctx.save();
        ctx.setTransform(IDENTITY.a, IDENTITY.b, IDENTITY.c, IDENTITY.d, IDENTITY.e, IDENTITY.f);
      });
      try {
        action();
      } finally {
        ctxs.forEach(function(ctx) {
          return ctx.restore();
        });
      }
    });
    _defineProperty3(_assertThisInitialized(_this2), "drawImage", function() {
      if (!_this2.props.imgSrc)
        return;
      _this2.image = new Image();
      _this2.image.crossOrigin = "anonymous";
      _this2.image.onload = _this2.redrawImage;
      _this2.image.src = _this2.props.imgSrc;
    });
    _defineProperty3(_assertThisInitialized(_this2), "drawGrid", function(ctx) {
      if (_this2.props.hideGrid)
        return;
      _this2.clearWindow(ctx);
      var gridSize = 25;
      var _this$coordSystem$can = _this2.coordSystem.canvasBounds, viewMin = _this$coordSystem$can.viewMin, viewMax = _this$coordSystem$can.viewMax;
      var minx = Math.floor(viewMin.x / gridSize - 1) * gridSize;
      var miny = Math.floor(viewMin.y / gridSize - 1) * gridSize;
      var maxx = viewMax.x + gridSize;
      var maxy = viewMax.y + gridSize;
      ctx.beginPath();
      ctx.setLineDash([5, 1]);
      ctx.setLineDash([]);
      ctx.strokeStyle = _this2.props.gridColor;
      ctx.lineWidth = _this2.props.gridLineWidth;
      if (!_this2.props.hideGridX) {
        var countX = minx;
        var gridSizeX = _this2.props.gridSizeX;
        while (countX < maxx) {
          countX += gridSizeX;
          ctx.moveTo(countX, miny);
          ctx.lineTo(countX, maxy);
        }
        ctx.stroke();
      }
      if (!_this2.props.hideGridY) {
        var countY = miny;
        var gridSizeY = _this2.props.gridSizeY;
        while (countY < maxy) {
          countY += gridSizeY;
          ctx.moveTo(minx, countY);
          ctx.lineTo(maxx, countY);
        }
        ctx.stroke();
      }
    });
    _defineProperty3(_assertThisInitialized(_this2), "drawInterface", function(ctx, pointer, brush) {
      if (_this2.props.hideInterface)
        return;
      _this2.clearWindow(ctx);
      ctx.beginPath();
      ctx.fillStyle = _this2.props.brushColor;
      ctx.arc(brush.x, brush.y, _this2.props.brushRadius, 0, Math.PI * 2, true);
      ctx.fill();
      ctx.beginPath();
      ctx.fillStyle = _this2.props.catenaryColor;
      ctx.arc(pointer.x, pointer.y, 4, 0, Math.PI * 2, true);
      ctx.fill();
      if (_this2.lazy.isEnabled()) {
        ctx.beginPath();
        ctx.lineWidth = 2;
        ctx.lineCap = "round";
        ctx.setLineDash([2, 4]);
        ctx.strokeStyle = _this2.props.catenaryColor;
        _this2.catenary.drawToCanvas(_this2.ctx["interface"], brush, pointer, _this2.chainLength);
        ctx.stroke();
      }
      ctx.beginPath();
      ctx.fillStyle = _this2.props.catenaryColor;
      ctx.arc(brush.x, brush.y, 2, 0, Math.PI * 2, true);
      ctx.fill();
    });
    _this2.canvas = {};
    _this2.ctx = {};
    _this2.catenary = new import_catenary_curve.Catenary();
    _this2.points = [];
    _this2.lines = [];
    _this2.erasedLines = [];
    _this2.mouseHasMoved = true;
    _this2.valuesChanged = true;
    _this2.isDrawing = false;
    _this2.isPressing = false;
    _this2.deferRedrawOnViewChange = false;
    _this2.interactionSM = new DefaultState();
    _this2.coordSystem = new CoordinateSystem({
      scaleExtents: props.zoomExtents,
      documentSize: {
        width: props.canvasWidth,
        height: props.canvasHeight
      }
    });
    _this2.coordSystem.attachViewChangeListener(_this2.applyView.bind(_assertThisInitialized(_this2)));
    return _this2;
  }
  var _proto = CanvasDraw2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    var _this2 = this;
    this.lazy = new import_lazy_brush.LazyBrush({
      radius: this.props.lazyRadius * window.devicePixelRatio,
      enabled: true,
      initialPoint: {
        x: window.innerWidth / 2,
        y: window.innerHeight / 2
      }
    });
    this.chainLength = this.props.lazyRadius * window.devicePixelRatio;
    this.canvasObserver = new ResizeObserver_es_default(function(entries, observer) {
      return _this2.handleCanvasResize(entries, observer);
    });
    this.canvasObserver.observe(this.canvasContainer);
    this.drawImage();
    this.loop();
    window.setTimeout(function() {
      var initX = window.innerWidth / 2;
      var initY = window.innerHeight / 2;
      _this2.lazy.update({
        x: initX - _this2.chainLength / 4,
        y: initY
      }, {
        both: true
      });
      _this2.lazy.update({
        x: initX + _this2.chainLength / 4,
        y: initY
      }, {
        both: false
      });
      _this2.mouseHasMoved = true;
      _this2.valuesChanged = true;
      _this2.clearExceptErasedLines();
      if (_this2.props.saveData) {
        _this2.loadSaveData(_this2.props.saveData);
      }
    }, 100);
    this.canvas["interface"] && this.canvas["interface"].addEventListener("wheel", this.handleWheel, makePassiveEventOption());
  };
  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    if (prevProps.lazyRadius !== this.props.lazyRadius) {
      this.chainLength = this.props.lazyRadius * window.devicePixelRatio;
      this.lazy.setRadius(this.props.lazyRadius * window.devicePixelRatio);
    }
    if (prevProps.saveData !== this.props.saveData) {
      this.loadSaveData(this.props.saveData);
    }
    if (JSON.stringify(prevProps) !== JSON.stringify(this.props)) {
      this.valuesChanged = true;
    }
    this.coordSystem.scaleExtents = this.props.zoomExtents;
    if (!this.props.enablePanAndZoom) {
      this.coordSystem.resetView();
    }
    if (prevProps.imgSrc !== this.props.imgSrc) {
      this.drawImage();
    }
  };
  _proto.render = function render() {
    var _this3 = this;
    return import_react.default.createElement("div", {
      className: this.props.className,
      style: _extends2({
        display: "block",
        background: this.props.backgroundColor,
        touchAction: "none",
        width: this.props.canvasWidth,
        height: this.props.canvasHeight
      }, this.props.style),
      ref: function ref(container) {
        if (container) {
          _this3.canvasContainer = container;
        }
      }
    }, canvasTypes.map(function(name) {
      var isInterface = name === "interface";
      return import_react.default.createElement("canvas", {
        key: name,
        ref: function ref(canvas) {
          if (canvas) {
            _this3.canvas[name] = canvas;
            _this3.ctx[name] = canvas.getContext("2d");
            if (isInterface) {
              _this3.coordSystem.canvas = canvas;
            }
          }
        },
        style: _extends2({}, canvasStyle),
        onMouseDown: isInterface ? _this3.handleDrawStart : void 0,
        onMouseMove: isInterface ? _this3.handleDrawMove : void 0,
        onMouseUp: isInterface ? _this3.handleDrawEnd : void 0,
        onMouseOut: isInterface ? _this3.handleDrawEnd : void 0,
        onTouchStart: isInterface ? _this3.handleDrawStart : void 0,
        onTouchMove: isInterface ? _this3.handleDrawMove : void 0,
        onTouchEnd: isInterface ? _this3.handleDrawEnd : void 0,
        onTouchCancel: isInterface ? _this3.handleDrawEnd : void 0
      });
    }));
  };
  return CanvasDraw2;
}(import_react.PureComponent);
_defineProperty3(CanvasDraw, "defaultProps", {
  onChange: null,
  loadTimeOffset: 5,
  lazyRadius: 12,
  brushRadius: 10,
  brushColor: "#444",
  catenaryColor: "#0a0302",
  gridColor: "rgba(150,150,150,0.17)",
  backgroundColor: "#FFF",
  hideGrid: false,
  canvasWidth: 400,
  canvasHeight: 400,
  disabled: false,
  imgSrc: "",
  saveData: "",
  immediateLoading: false,
  hideInterface: false,
  gridSizeX: 25,
  gridSizeY: 25,
  gridLineWidth: 0.5,
  hideGridX: false,
  hideGridY: false,
  enablePanAndZoom: false,
  mouseZoomFactor: 0.01,
  zoomExtents: {
    min: 0.33,
    max: 3
  },
  clampLinesToDocument: false
});
CanvasDraw.propTypes = true ? {
  onChange: import_prop_types.default.func,
  loadTimeOffset: import_prop_types.default.number,
  lazyRadius: import_prop_types.default.number,
  brushRadius: import_prop_types.default.number,
  brushColor: import_prop_types.default.string,
  catenaryColor: import_prop_types.default.string,
  gridColor: import_prop_types.default.string,
  backgroundColor: import_prop_types.default.string,
  hideGrid: import_prop_types.default.bool,
  canvasWidth: dimensionsPropTypes,
  canvasHeight: dimensionsPropTypes,
  disabled: import_prop_types.default.bool,
  imgSrc: import_prop_types.default.string,
  saveData: import_prop_types.default.string,
  immediateLoading: import_prop_types.default.bool,
  hideInterface: import_prop_types.default.bool,
  gridSizeX: import_prop_types.default.number,
  gridSizeY: import_prop_types.default.number,
  gridLineWidth: import_prop_types.default.number,
  hideGridX: import_prop_types.default.bool,
  hideGridY: import_prop_types.default.bool,
  enablePanAndZoom: import_prop_types.default.bool,
  mouseZoomFactor: import_prop_types.default.number,
  zoomExtents: boundsProp,
  clampLinesToDocument: import_prop_types.default.bool
} : {};
export {
  CanvasDraw as default
};
/*! Bundled license information:

react-is/cjs/react-is.development.js:
  (** @license React v16.13.1
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

object-assign/index.js:
  (*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  *)
*/
//# sourceMappingURL=react-canvas-draw.js.map
